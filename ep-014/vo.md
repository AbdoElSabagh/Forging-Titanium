Hey everybody and welcome to another episode of Forging Titanium. This week's episode is part 1 of a 3 part series where we will create a fun experiment called "Twisti" that'll make use of a native Android module, 3D graphics and rendering, and realtime communication via sockets. Today we'll be exploring how we can use a native Android module to extend the functionality present in the `Titanium.Accelerometer` module. The first thing you should do before embarking on native module creation is check out the comprehensive guides in the wiki. Here you can find everything you need to get started creating your own native modules. The guides also serve as a great reference for even veteran module developers. If anything in this screencast is confusing and you need further clarification, those guides would be your best bet.Before you can create an Android module, you need to make sure you have all the prerequisites accounted for, as listed here. If you are missing any of these, be sure to follow the links in the wiki to get the necessary packages. One additional note is that we'll be developing this module using Eclipse, as it is Google's preferred IDE for Android development so you'll likely want to download that as well.One final step is to make sure your command line environment is prepared for module development. Follow the Titanium Command Line Interface guide that details for each supported OS how you can run the module build scripts. It should take you less than a minute to get that ready for your OS.OK, everything should now be in place, let's create the Android module. Let's open up our command line interface type in the following command... The `titanium` script, which you should now have in your PATH as per the Titanium Command Line Interface guide, will be given an action of `create`. When `create` is designated, we give it the following series of arguments to indicate that we'll be creating a native module. `type` and `platform` indicate that we are building a native module for android, respectively. Next we give the module a name and id, very much like normal project creation in Titanium Studio. Finally, we give the build script the path to our Android SDK. You will obviously need to change this to the path appropriate to your system.When we run this command we will then receive the anticlimactic message "created android module project". Let's take a quick peek inside of our newly created project directory. We can see that the Titanium build script did a lot of the grunt work for us in terms of creating a project that we can almost immediately use as a Titanium module. To get an even better look, let's load this project into Eclipse...With Eclipse open we'll go to file -> import -> existing projects into workspace. Click "browse" and go to the root of the newly created module directory. Click finish and the module is then loaded into Eclipse. There's _lots_ of files and directories here, all of which are discussed in detail in the module development wiki guides. Today we're only going to discuss the necessary changes for creating a module that returns additional sensor data from Android.Let's open up the source directory in our project. The first thing we'll do is delete the `ExampleProxy.java` file. This module will only need to return data via a module level events, so no proxies for dynamic objects or UI elements are necessary. Now let's open up the TestModule.java file. In here we see the basic layout for module level code. Notice the @Kroll annotations throughout the class definition. These annotations are how modules, properties, and methods are exposed to Titanium's Javascript API via your module. We'll discuss this a little more in a bit.So we have this default module... what do we do with it? Where can we get examples of how to add functionality to it? Fortunately for us, the open source Titanium mobile SDK has loads of them. For those unaware, the core Javascript API for Titanium is effectively just a series of native modules, built in this same fashion, that have been integrated into the SDK.Let's go out to github and check out the existing accelerometer module in the SDK. In the titanium_mobile project, in the android modules section, we see a listing of all the modules exposed by the core Titanium Javascript API. If we click through to the source code for the module... we find a relatively small, concise blueprint for registering sensor events and then sending them back through the Javascript API. Don't worry if you don't understand all, or any, of this code right now. The important lesson here is that when you do decide to dive into native module development, the titanium_mobile SDK itself is a treasure trove of examples written by Appcelerator's platform engineers.Let's go back to Eclipse and take a look at the module I created, basing it largely on the existing Accelerometer module for Android. At the very beginning of the class definition you'll notice that this module, like the SDK's Accelerometer, implements SensorEventListener. Implementing this class is what allows us to receive native sensor events from android devices. The majority of the variables created here are for 3 dimensional calculations based on the accelerometer and magnetic field values we receive and are used a little later in the code. We are still using the default module constructor. Below it we see methods for both adding and removing event listeners. We override these functions so that we can have more control over how and when they are registered. The onAccuracyChanged function is not used by our module and is given a default, empty implementation. Finally we arrive at the onSensorChanged function. This is the function that will be called whenever Android receives a sensor event for which we've registered. The first thing we do is identify which sensor sent the event, then store it's values for use later. We do this because we need both the current accelerometer and magnetic field values to perform the following 3D transformations.When we do have both of these values, we perform a series of 3D operations provided by Android that I'm not even going to pretend to fully understand. What is effectively happening is that the gravity vector provided by the accelerometer is used in conjunction with the direction of the magnetic field to deliver a set of values that give the physical orientation of the device relative to magnetic north. You got all that? In the end, we'll send back to our Titanium app, via an event, the latest x, y, and z values of the accelerometer, as well as the azimuth, pitch, and roll representing the orientation of the device. Building this module so that we can use it in our Titanium apps is simple. We just go back out the command line interface, make sure we are at the top level of our module's project directory, then type `ant`. `ant` will launch our build scripts and if you have everything configured correctly, you will see a **BUILD SUCCESSFUL** message after a few seconds. If we then go into the `dist` directory, we'll find our module ready for use. The naming convention seen here for the zipped module is the module id followed by the platform followed by the version. 