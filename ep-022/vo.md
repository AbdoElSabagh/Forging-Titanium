Hey everybody! Welcome to another episode of Forging Titanium! Today we're gonna do something a little different. We're going to take a popular app from the wild and see how we can implement some of its features in Titanium. And if you guys like this, we may do it more often. Today's target: the animated menu from the Path mobile app.For those unfamiliar with Path, it's a relatively new social networking application. Its differentiator seems to be that it focuses on closer connections than the existing social networks do, like family and loved ones. But frankly, I don't really care what it does. What I do care about is the really slick menu they have. In the bottom left corner of the app there's a menu button you press, which causes option icons to fly out in a staggered arc pattern. Very cool, unique, and unobtrusive, key elements to great eye-catching UI.So we didn't get a very good look from the Path video, but don't worry. Not only are you going to get a good look on iPhone, iPad, and Android, but you're also going to get all the code necessary to do it yourself. I'll be walking through how I created a cross-platform version of a Path-like menu, with no loss in performance or polish. Before heading to the code, let's take a look at the Path-like menu running on the iOS simulator and Android emulator. It'll give you a better sense of what needed to be accomplished. ***** DEMO THE APP *****Now that we know what was involved, let's see how I did it. One thing to note right off the bat is the power displayed by one of Titanium's most basic components. This interface was created using nothing more than ImageViews. As seen in the demonstrated app, Titanium's native UI components are infused with much more than static display capabilities. The ability to employ transformations and animations allows you to not only create awesome, engaging UI, but to do so with native performance. Cause let's face it, what good is a cool animation is it performs poorly?We'll start in the `app.js`. Here you can see that I've constructed a very simple, single window app. Right at the top here we can see where I require and configure path.js. The `iconList` specifies, you guessed it, the list of icons our menu will display. We give each an image and an optional id. The id can make your interactions easier to define later on in `click` events. While this is the only property defined here, there's a whole list of properties you can use to customize the menu. Be sure to check out the documentation at the project's github repository for the full listing...Next we create a label that will tell us the index and id of the menu icons we click. This label will be modified from the `iconClick` event of our Path-like menu, which tells us when these icon clicks occur. Through use of the `iconClick` event, you are able to loosely couple your application specific logic from that of the menu.Finally, for the purposes of demonstration, we create a button that resets the state of the menu and then assemble our view hierarchy...OK, now on to the nuts and bolts of the path.js file. At the beginning of the commonjs module we establish the default values and platform for the application. Additionally, if we are on iOS, we require the `path.animator` module. This module helps alleviate the limitations of transform animations on native iOS views. For complete details and code, check out the Github repository for the relatively simple module here...***** SHOW path.animator URL *****Next we set the configuration settings for the menu and move on to creating our UI and animations. The first thing we'll create are the reusable `fadeOut` and `fadeLarge` animations used when and icon is clicked. Since the same animation and transform is applied no matter what icon is clicked, we may as well reuse the same animations for all icons.After that we create the menu button itself, along with all the menu icons that will fly out when we click it. The menu button, and all the icons, are also assigned click handlers for dictating the behavior of the menu. Finally we expose the `initMenu()` function on the menu object so that developers using this commonjs module will be able to reset the menu to its start state.That all seems pretty basic, huh? Well let's dive into some of the math and animation chaining that really gives the menu its unique look and feel...Let's take a look at `createMenuButton()`. This one is pretty basic. We define the `open` and `close` animations that cause the menu button to rotate 45 degrees when opened, or back to its original position when closed...***** SHOW THIS IN APP *****Other than that, we just create the ImageView to represent it and we are all done. The process in `createMenuIcon()` is a little more involved though... We want the menu icons to animate to an evenly spaced position on an arc of a predetermined radius. In addition, we want that cool little bounce at the end of the icon's travels. Oh, and we don't want them to come out all at once, we want a little bit of a stagger between each. To do so, we're going to use a little bit of trigonometry, as well as taking advantage of Titanium's ability to delay and chain animations. At the top here we are defining the values for the icon based on its index. I'm not going to give a trig lesson here, but just know that this is how the icon gets positioned along the arc, and it's also how it's extra "bounce" value is determined. After that, we define the 4 critical animations for the icon based on these values. The 4 animations are:* openBounce - which is the extended bounce position traveled by the icon when the menu is opened.* openFinal - which is the final position of the icon after opening, where it rests after the bounce* closeBounce - which is going back to the bounce position when the menu is closing* closeFinal - which is resting place, behind the menu button, when the close is finishedNext we see a small divergence due to the necessity of a native module for iOS's rotations. When we aren't on iOS, we can simply define the rotation transform directly on the animation. If it is iOS, though, we need to create the icon with the `path.animator` module, which has a different method for rotation...If we jump up to the `handleMenuButtonClick()` function we can see where this divergence becomes a factor. Under normal circumstances, based on the current state of the menu, the animations can simple be launched with the `animate()` function and all works well. With iOS though, we need to manually fire the new `rotate()` function, which is part of the icon created with the native module...When finished assigning the values to our icon and its animations, we return the icon...To wrap up the analysis, we'll look at `handleMenuIconClick()`. Here we can see where the custom `iconClick` event is fired that allows us to react based on the particular icon clicked. To wrap up the handler we need to fade out all of our icons... but we also need to scale up the icon we clicked to cue the user to its selection... You'll probably notice the special code in place for android. While iOS scales its views from the center, android does so from the top-left corner. This causes the icon to appear to move while it's scaling up or down. To resolve this, when on Android, we simply move the left and bottom values in lockstep with the scaling animation. In this way we can still use the same animations for iOS and Android while accounting for the underlying differences between the native platforms.And there you have it. An extremely cool and popular UI done cross-platform, in a single code base, with Titanium. In this demonstration and walkthrough, we saw some of the areas where Titanium excels right out of the box. In addition, and perhaps more importantly, we saw how Titanium is near infinitely extensible when obstacles do occur. Whether it's as simple as branching code based on the mobile OS, or more involved like creating a native module, you'll quickly find that Titanium's extensibility keeps you from hitting dead-ends and allows you to deliver stunning apps that are indistinguishable from their native-built counterparts.Thanks for checking out this episode of Forging Titanium. See ya next time! 